/*PB3.0系统自动生成demo源码文件*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/mode.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <setjmp.h>


#include <time.h>
#include "pbconstval.h" 
#include "pbstructdef.h" 
#ifdef ORACLE_DATABASE
EXEC SQL include "pbranchdb.h";
#else
#include "pbranchdb.h"
#endif
#include "pberrlog.h"
#include "pbglbvardef.h"
#include "pbbasefunc.h"
#include "pbvarmacro.h"

#include "pbdb.h"
#include "fml32.h"
#include "atmi.h"

EXEC SQL include "pb_s_agt_batch.h";
EXEC SQL include "pbsrv.h";
extern char headbuf[300];
extern char flowNo1[16];

/** Added by Ma Shaojie - 20120530 **/
struct s_acc_info_stru
{
    char     acc[32+1]; 
	char     card_flag;
	char     inst_no[4+1];
	char     acc_stat[2+1];
	char     cstm_name[60+1];
	double   aval_bal;
	char     draw_type; 
	char     acc_pwd[16+1];
	char     cstm_no[14+1];
	char     prd_no[4+1]; 
	char     in_acc[25+1];
	char     qry_pwd[16+1];
};

$struct s_sc_agt_bat_item_mgmt AgtMgmt;

$struct s_sc_agt_para_mgmt ParaMgmt;

$char AccDate[10+1];
$char Hostseqno[20+1];
$char InstNo[4+1];
$char TlrNo[6+1];
$char BatchNo[10+1];

$int BATCHNO;
$long TotalNum = 0;
$double TotalAmt = 0.00;

int AgtBatchSend_new()
{
	EXEC SQL BEGIN DECLARE SECTION;
	struct s_pb_net_dtl net_dtl;
	char backup2[128+1];

	/* Added by Ma Shaojie 20120523 - Start */
		char updCustNm[128];
		char updPayAcct[32+1];
		char s_amt[32+1];
		double updAmt;
		char updInstno[32];
	/* 20120523 - End */
	EXEC SQL END DECLARE SECTION;
	char inst_no[4+1];
	char cmd[400+1];
	char btchNb[32+1];
	char btchNm[128+1];
	char operTyp[2+1];
	char currencyTyp[6+1];
	char cashFlg[2+1];
	char remarkCd[16+1];
	char remark[128+1];
	char backup1[128+1];
	char backup3[128+1];
	char seqNb[32+1];
	char payAcct[32+1];
	char payCustNm[128+1];
	char rcvAcct[32+1];
	char rcvCustNm[128+1];
	char memo[128+1];
	char hostSeqNb[10+1];
	char err_msg[256+1];
	char tran_time[14+1];
	char tmp_time[80+1];
	char buff[2048+1];
	char tmp_str[50][128+1];
	dtime_t dt_time;
	long totalQnt = 0;
	long errcode = 0;
	int ret = 0;
	int i = 0;
	long j = 0;
	double totalAmt = 0.00;
	double amt = 0.00;
	FILE *fp;
	char txtfile[256+1];
	char cfgfile[128+1];
	char xmlinput[256+1];
	char filepath[128+1];
	char xmlinputfilename[128+1];
	char *p = NULL;
	char *q = NULL;

	struct s_acc_info_stru acc_info;
    int i_flag = 0;

	memset( &net_dtl, 0, sizeof( net_dtl ) );
	memset( btchNb, 0, sizeof( btchNb ) );
	memset( btchNm, 0, sizeof( btchNm ) );
	memset( operTyp, 0, sizeof( operTyp ) );
	memset( currencyTyp, 0, sizeof( currencyTyp ) );
	memset( cashFlg, 0, sizeof( cashFlg ) );
	memset( remarkCd, 0, sizeof( remarkCd ) );
	memset( remark, 0, sizeof( remark ) );
	memset( backup1, 0, sizeof( backup1 ) );
	memset( backup2, 0, sizeof( backup2 ) );
	memset( backup3, 0, sizeof( backup3 ) );
	memset( seqNb, 0, sizeof( seqNb ) );
	memset( payAcct, 0, sizeof( payAcct ) );
	memset( payCustNm, 0, sizeof( payCustNm ) );
	memset( rcvAcct, 0, sizeof( rcvAcct ) );
	memset( rcvCustNm, 0, sizeof( rcvCustNm ) );
	memset( memo, 0, sizeof( memo ) );
	memset( hostSeqNb, 0, sizeof( hostSeqNb ) );
	memset( err_msg, 0, sizeof( err_msg ) );
	memset( tran_time, 0, sizeof( tran_time ) );
	memset( tmp_time, 0, sizeof( tmp_time ) );
	memset( &dt_time, 0, sizeof( dt_time ) );
	memset( txtfile, 0, sizeof( txtfile ) );
	memset( cfgfile, 0, sizeof( cfgfile ) );
	memset( xmlinput, 0, sizeof( xmlinput ) );
	memset( xmlinputfilename, 0, sizeof( xmlinputfilename ) );
	memset( filepath, 0, sizeof( filepath ) );
	memset( buff, 0, sizeof( buff ) );
	memset( inst_no, 0, sizeof( inst_no ) );
	memset( updCustNm, 0, sizeof( updCustNm ) );
	memset( updPayAcct, 0, sizeof( updPayAcct ) );
	memset( s_amt, 0, sizeof( s_amt ) );
	memset( updInstno, 0, sizeof( updInstno ) );
	memset( &acc_info, 0, sizeof( acc_info ) );

	GetPoolDataByName( "ABSHEAD", "_seq_no", 0, 0, net_dtl.seqno, 0);
	ret = PayGetPbDate( net_dtl.trandate );
	if( ret < 0 )
	{
		WriteLog( ERR_LVL, "取PB系统日期失败!\n" );
		errcode = 99999; 
		strcpy( err_msg, "取PB系统日期失败!" );
		PutPoolDataByName( "ABSHEAD", "app_err_no", 0, 0, (char *)&errcode, 0 );
		PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
		/***冲正已记成功的客户帐***/
		ret = NetBank_PL_InsRevJnl();
		if( ret < 0 )
		{
			WriteLog( ERR_LVL, "插入冲正流水表失败!" );
			errcode = 99999;	
			strcpy( err_msg, "插入冲正流水表失败!" );
			PutPoolDataByName( "ABSHEAD", "app_err_no", 0, 0, (char *)&errcode, 0 );
			PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
		}
	
		return (-1);
	}
	memset( AccDate, 0, sizeof( AccDate ) );
	strcpy( AccDate, net_dtl.trandate );
	memset( InstNo, 0, sizeof( InstNo ) );
	memset( TlrNo, 0, sizeof( TlrNo ) );
	GetPoolDataByName( "ABSHEAD", "organ_no", 0, 0, inst_no, 0);
	GetPoolDataByName( "ABSHEAD", "_tlr_no", 0, 0, TlrNo, 0);
	rtrim( TlrNo );
	/***取系统时间***/
	dtcurrent( &dt_time );
	dttoasc( &dt_time, tmp_time );
	rtrim( tmp_time );
	WriteLog( APP_LVL, "系统时间tmp_time[%s]\n", tmp_time );
	memcpy( tran_time, tmp_time, 4 );
	memcpy( tran_time + 4, tmp_time + 5, 2 );
	memcpy( tran_time + 6, tmp_time + 8, 2 );
	memcpy( tran_time + 8, tmp_time + 11, 2 );
	memcpy( tran_time + 10, tmp_time + 14, 2 );
	memcpy( tran_time + 12, tmp_time + 17, 2 );
	rtrim( tran_time );
	WriteLog( APP_LVL, "系统时间tran_time[%s]\n", tran_time );

	GetPoolDataByName( "BUSIIB", "transfilename", 0, 0, xmlinputfilename, 0 );
	WriteLog( APP_LVL, "xmlinputfilename[%s]\n", xmlinputfilename );
	sprintf( filepath, "%s/print/NETBANK/TOPB/%s", getenv( "HOME" ) ,xmlinputfilename);
	
	
	/***生成统一格式文件***/
	ret = gen_reg_file_snd_new( filepath );
	if( ret < 0 )
	{
		WriteLog( ERR_LVL, "生成统一格式文件错!\n" );
		errcode = 99999;
		strcpy( err_msg, "生成统一格式文件错!" );
		PutPoolDataByName( "ABSHEAD", "app_err_no", 0, 0, (char *)&errcode, 0 );
		PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
		/***冲正已记成功的客户帐***/
		ret = NetBank_PL_InsRevJnl();
		if( ret < 0 )
		{
			WriteLog( ERR_LVL, "插入冲正流水表失败!" );
			errcode = 99999;	
			strcpy( err_msg, "插入冲正流水表失败!" );
			PutPoolDataByName( "ABSHEAD", "app_err_no", 0, 0, (char *)&errcode, 0 );
			PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
		}
		return (-1);
	}
	rtrim(AgtMgmt.batch_no);
	rtrim(AgtMgmt.inst_no);
	rtrim(AgtMgmt.summ_no);
	rtrim(AgtMgmt.summ_note);

	strcpy( net_dtl.batchno, AgtMgmt.batch_no );
	strcpy( net_dtl.instno, AgtMgmt.inst_no );
	strcpy( net_dtl.hopedate, net_dtl.trandate );
	net_dtl.agt_num = BATCHNO;
WriteLog( ERR_LVL, "ooooooooooooooo[%d]!\n",net_dtl.agt_num );
	strcpy( net_dtl.btchnb, flowNo1 );
	strcpy( net_dtl.remarkcd, AgtMgmt.summ_no );
	strcpy( net_dtl.remark, AgtMgmt.summ_note );
	strcpy( net_dtl.backup2, AgtMgmt.batch_no );

	/***发起柜台批量***/
	ret = reg_to_server_snd_new();
	if( ret==-13 )
	{
		WriteLog( ERR_LVL, "批量通讯超时，状态未知!\n" );
		errcode = 99999;
		strcpy( err_msg, "通讯超时，状态未知，请检查账户余额!" );
		i_flag=-13;
	}
	else if( ret==-1 )
	{
		WriteLog( ERR_LVL, "转柜台批量处理时错!\n" );
		errcode = 99999;
                GetPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
		/***冲正已记成功的客户帐***/
		ret = NetBank_PL_InsRevJnl();
		if( ret < 0 )
		{
			WriteLog( ERR_LVL, "插入冲正流水表失败!" );
			errcode = 99999;	
			strcpy( err_msg, "插入冲正流水表失败!" );
			PutPoolDataByName( "ABSHEAD", "app_err_no", 0, 0, &errcode, 0 );
			PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
		}
		i_flag=-1;
	}
	else if( ret==-2 )
	{
		WriteLog( ERR_LVL, "您的代发笔数超限，请到网银开户网点做修改!\n" );
		errcode = 99999;
		strcpy( err_msg, "您的代发笔数超限，请到网银开户网点做修改!" );
		/***冲正已记成功的客户帐***/
		ret = NetBank_PL_InsRevJnl();
		if( ret < 0 )
		{
			WriteLog( ERR_LVL, "插入冲正流水表失败!" );
			errcode = 99999;	
			strcpy( err_msg, "插入冲正流水表失败!" );
			PutPoolDataByName( "ABSHEAD", "app_err_no", 0, 0, &errcode, 0 );
			PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
		}
		i_flag=-1;
	}
	GetPoolDataByName( "PAGTBUF", "accno", 0, 0, updPayAcct, 0 );
        rtrim( updPayAcct );
        GetPoolDataByName( "PAGTBUF", "amt", 0, 0, s_amt, 0 );
        rtrim(s_amt);
        updAmt=atof(s_amt);

    /* Added by MSJ 20140624 - Start */
    ret = PayGetAccInfo( updPayAcct, &acc_info);
    if( ret < 0 )
    {
            WriteLog ( ERR_LVL, "取帐号信息错[%s]", updPayAcct );
    }
    else
    {
        PutPoolDataByName( "ABSHEAD", "app_err_no", 0, 0, &errcode, 0 );      
        PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
    }

    rtrim( acc_info.cstm_name);
    rtrim( acc_info.inst_no );
    strcpy( net_dtl.payinstno, acc_info.inst_no );
    strcpy( updCustNm, acc_info.cstm_name );
    WriteLog( APP_LVL, "updCustNm[%s] payinstno[%s]", updCustNm, net_dtl.payinstno );
    /* Added by MSJ 20140624 - End */

	EXEC SQL UPDATE t_pb_net_dtl
		SET batchno = :net_dtl.batchno,
		instno = :net_dtl.instno,
		hopedate = :net_dtl.hopedate,
		agt_num = :net_dtl.agt_num,
		btchnb = :net_dtl.btchnb,
		remarkcd = :net_dtl.remarkcd,
		remark = :net_dtl.remark,
		backup1 = :net_dtl.backup1,
		backup2 = :net_dtl.backup2,
		backup3 = :net_dtl.backup3,
		payacc = :updPayAcct,
		transamt = :updAmt,
			/* Added by MSJ 20140624 */
		paycustname = :updCustNm,
		payinstno=:net_dtl.payinstno,
		transtats[4,4] = '0'
	WHERE trandate = :net_dtl.trandate
		AND seqno = :net_dtl.seqno;
	WriteLog( ERR_LVL, "sssssssss[%s][%s]\n",net_dtl.trandate,net_dtl.seqno );
	if( SQLCODE || sqlca.sqlerrd[2] != 1 )
	{
		WriteLog( ERR_LVL, "更新网银流水表出错![%d][%d]\n",SQLCODE,sqlca.sqlerrd[2] );
		errcode = 99999;
		strcpy( err_msg, "更新网银流水表出错!" );
		PutPoolDataByName( "ABSHEAD", "app_err_no", 0, 0, &errcode, 0 );
		PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
		return (-1);
	}
	if( i_flag<0 )
    {
        WriteLog( ERR_LVL, "更新网银流水表完成[%d]!\n", i_flag );
        return (-1);
    }



	PutPoolDataByName( "BUSIIB", "hostSeqNb", 0, 0, Hostseqno, 0 );
	
	return ( 0 );
}

int 
reg_to_server_snd_new()
{
	EXEC SQL BEGIN DECLARE SECTION;
	char idflag[1+1];
	char content[250+1];
	long fmldata;
	EXEC SQL END DECLARE SECTION;

	FBFR32 *sendbuf, *recvbuf;		/*FML32 上下传缓冲包*/
	long RcvLen = 0;				/*FML--TPCALL 返回时接收长度*/
	int rval;
	int i;
	long agt_num = 0;
	long hoststat = 1;
	char hostmsg[80+1];

	char getstr[50+1];				/*WSNADDR env*/
	char putstr[50+1];				/*WSNADDR env*/
	char _SendFile[1024+1];

	char AGTMAINSERVER[20+1];		/*批量主控SERVER*/

	FML_TRAN_STRUCT fml_tran_head, fml_tran_rec;
	long pbsave = 0;
	long port = 0;

	memset( Hostseqno, 0, sizeof( Hostseqno ) );
	memset( content, 0, sizeof( content ) );
	memset( hostmsg, 0, sizeof( hostmsg ) );
	memset( _SendFile, 0, sizeof( _SendFile ) );

	GetPoolDataByName( "ABSHEAD", "_seq_no", 0, 0, Hostseqno, 0);
	WriteLog( ERR_LVL, "Hostseqno[%s]\n", Hostseqno );
	/* 对上传包公共包头赋值 */
	memset( &FrontBuff, 0x00, sizeof( FrontBuff ) );
	strcpy( FrontBuff.AreaNo, "000000" );		/*区域号*/
	strcpy( FrontBuff.ChnlNo, "001" );			/*渠道号*/
	FrontBuff.Save = '1';						/*FML包标志*/

	memset( AGTMAINSERVER, 0x00, sizeof( AGTMAINSERVER ) );

	strcpy( FrontBuff.FTranCode, "6250" );		/*外部交易码*/
	strcpy( AGTMAINSERVER, "FmlAdt" );

	/*初始化公共包头PBHEAD(0000)*/
	memset( &fml_tran_head, 0x00, sizeof( fml_tran_head ) );
	rval = GetFmlTran( FrontBuff.AreaNo, FrontBuff.ChnlNo, "0000", '0', &fml_tran_head );
	if( rval < 0 )
	{
		WriteLog( ERR_LVL, "GetFmlTran(0000) Fail ret [%d]", rval );
		return (-1);
	}

	/*初始化交易包*/
	memset( &fml_tran_rec, 0x00, sizeof( fml_tran_rec ) );
	rval = GetFmlTran( FrontBuff.AreaNo, FrontBuff.ChnlNo, FrontBuff.FTranCode, '0', &fml_tran_rec );
	if( rval < 0 )
	{
		WriteLog(ERR_LVL, "GetFmlTran(%s) Fail ret [%d] ", FrontBuff.FTranCode, rval );
		return ( -1 );
	}
	
	/*分配FML缓冲池*/
	sendbuf = (FBFR32 *)tpalloc( "FML32", NULL, PACKDATA_LEN + 1 );
	if( sendbuf == NULL )
	{
		WriteLog( ERR_LVL, "Tpalloc sendbuf failed!" );
		/* tpfree( (char *)sendbuf ); */
		return ( -1 );
	}
	rval = Finit32( sendbuf, (FLDLEN32)Fsizeof(sendbuf) );

	recvbuf = (FBFR32 *)tpalloc( "FML32", NULL, PACKDATA_LEN + 1 );
	if( recvbuf == NULL )
	{
		WriteLog( ERR_LVL, "Tpalloc recvbuf failed!" );
		tpfree( (char *) sendbuf );
		/* tpfree( (char *) recvbuf ); */
		return ( -1 );
	}
	rval = Finit32( recvbuf, (FLDLEN32)Fsizeof( recvbuf ) );

	/*为请求交易公共包头赋值*/
	WriteLog( APP_LVL, "fml_tran_head.FldNum=[%ld]", fml_tran_head.FldNum );
	for( i = 0; i < fml_tran_head.FldNum; i++ )
	{
		if( strncmp( fml_tran_head.Flds[i].TranFldName, "tran_flag", 10 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s] ", fml_tran_head.Flds[i].FldFmlId, fml_tran_head.Flds[i].TranFldName );
			fmldata = 0;
			Fchg32( sendbuf, fml_tran_head.Flds[i].FldFmlId, 0, ( char * )&fmldata, NULL );
		}
		if( strncmp( fml_tran_head.Flds[i].TranFldName, "chnl_no", 10 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s] ", fml_tran_head.Flds[i].FldFmlId, fml_tran_head.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_head.Flds[i].FldFmlId, 0, "0", NULL );
		}
		if( strncmp( fml_tran_head.Flds[i].TranFldName, "_tx_op_stat", 10 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s] ", fml_tran_head.Flds[i].FldFmlId, fml_tran_head.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_head.Flds[i].FldFmlId, 0, "N", NULL );
		}
		if( strncmp( fml_tran_head.Flds[i].TranFldName, "organ_no", 10 ) == 0 )
		{
			WriteLog( ERR_LVL, "InstNo[%s]\n", InstNo );
			WriteLog( APP_LVL, "fld. = [%d][%s] ", fml_tran_head.Flds[i].FldFmlId, fml_tran_head.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_head.Flds[i].FldFmlId, 0, InstNo, NULL );
		}
		if( strncmp( fml_tran_head.Flds[i].TranFldName, "query_inst", 10 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s] ", fml_tran_head.Flds[i].FldFmlId, fml_tran_head.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_head.Flds[i].FldFmlId, 0, InstNo, NULL );
		}
		if( strncmp( fml_tran_head.Flds[i].TranFldName, "_seq_no", 10 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s] ", fml_tran_head.Flds[i].FldFmlId, fml_tran_head.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_head.Flds[i].FldFmlId, 0, Hostseqno, NULL );
		}
		if( strncmp( fml_tran_head.Flds[i].TranFldName, "_tlr_no", 10 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s] ", fml_tran_head.Flds[i].FldFmlId, fml_tran_head.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_head.Flds[i].FldFmlId, 0, TlrNo, NULL );
		}
		if( strncmp( fml_tran_head.Flds[i].TranFldName, "_tx_code", 10 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s] ", fml_tran_head.Flds[i].FldFmlId, fml_tran_head.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_head.Flds[i].FldFmlId, 0, "6250", NULL );
		}

		/*filename*/
		if( strncmp( fml_tran_head.Flds[i].TranFldName, "send_filename", 13 ) == 0 )
		{
			memset( _SendFile, 0x00, sizeof( _SendFile ) );
			rtrim( BatchNo );
			rtrim( InstNo );
			rtrim( AccDate );
			sprintf( _SendFile, "%s%s%s%d.txt", BatchNo, InstNo, AccDate, BATCHNO );

			WriteLog( APP_LVL, "fld. = [%d][%s] ", fml_tran_head.Flds[i].FldFmlId, fml_tran_head.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_head.Flds[i].FldFmlId, 0, _SendFile, NULL );
		}
	}
	/***报文体赋值***/
	for( i = 0; i < fml_tran_rec.FldNum; i++ )
	{
		/* filename */
		if( strncmp( fml_tran_rec.Flds[i].TranFldName, "file_name", 9 ) == 0 )
		{
			memset( _SendFile, 0x00, sizeof( _SendFile ) );
			rtrim( BatchNo );
			rtrim( InstNo );
			rtrim( AccDate );
			sprintf( _SendFile, "%s%s%s%d.txt", BatchNo, InstNo, AccDate, BATCHNO );

			WriteLog( ERR_LVL, "fffffffffffffff[%s]",_SendFile);
			WriteLog( ERR_LVL, "fld. = [%d][%s]", fml_tran_rec.Flds[i].FldFmlId, fml_tran_rec.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, _SendFile, NULL );
		}
		/* batch_no */
		if( strncmp( fml_tran_rec.Flds[i].TranFldName, "batch_no", 8 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s]", fml_tran_rec.Flds[i].FldFmlId, fml_tran_rec.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, AgtMgmt.batch_no, NULL );
		}
		/* busiflag */
		if( strncmp( fml_tran_rec.Flds[i].TranFldName, "flag", 8 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s]", fml_tran_rec.Flds[i].FldFmlId, fml_tran_rec.Flds[i].TranFldName );
			WriteLog( APP_LVL, "TotalNum[%d]MAXNUM[%d]\n", TotalNum, AgtMgmt.max_num );
			Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, "1", NULL );
			EXEC SQL select content into :content from t_pay_sys_para where inst_no='NET' and data_code='BAT_ON';
			if( SQLCODE == 100 )
			{
				if( TotalNum > AgtMgmt.max_num )
				{
					return -2;
				}
				if( TotalNum > 500 )
				{
					WriteLog( ERR_LVL, "TotalNum[%ld],content[%s]\n", TotalNum,content );
					Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, "0", NULL );
				}
				WriteLog( APP_LVL, "SQLCODE[%ld]\n", SQLCODE );
			}
			else
			{
				rtrim( content );
				if( strlen(content+1)!=0 && TotalNum >= atol(content+1) )
				{
					Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, "0", NULL );
					WriteLog( ERR_LVL, "TotalNum[%ld],content[%s]\n", TotalNum,content );
				}
				if( content[0]=='A' )
				{
					if( TotalNum > AgtMgmt.max_num )
					{
						Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, "0", NULL );
						WriteLog( ERR_LVL, "TotalNum[%ld],max_num[%ld]\n", TotalNum,AgtMgmt.max_num );
					}
				}
				else
				{
					if( TotalNum > AgtMgmt.max_num )
					{
						WriteLog( ERR_LVL, "TotalNum[%ld],cotent[%s]\n", TotalNum,content );
						return -2;
					}
				}
			}
		}
		/* agt_num */
		agt_num = BATCHNO;
		if( strncmp( fml_tran_rec.Flds[i].TranFldName, "rec_no", 7 ) == 0 )
		{
			WriteLog( APP_LVL, "agt_num[%d]\n", agt_num );
			WriteLog( APP_LVL, "fld. = [%d][%s]", fml_tran_rec.Flds[i].FldFmlId, fml_tran_rec.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, (char *)&agt_num, NULL );
		}
		/* total_num */
		if( strncmp( fml_tran_rec.Flds[i].TranFldName, "rec_num", 9 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s]", fml_tran_rec.Flds[i].FldFmlId, fml_tran_rec.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, (char *)&TotalNum, NULL );
		}
		/* idflag */
		memset( idflag, 0, sizeof( idflag ) );
		idflag[0] = '1';
		if( strncmp( fml_tran_rec.Flds[i].TranFldName, "prt_flag", 8 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s]", fml_tran_rec.Flds[i].FldFmlId, fml_tran_rec.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, (char *)&idflag, NULL );		/*校验证件/户名标志*/
		}
		/* total_amount */
		if( strncmp( fml_tran_rec.Flds[i].TranFldName, "amt", 9 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s]", fml_tran_rec.Flds[i].FldFmlId, fml_tran_rec.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, (char *)&TotalAmt, NULL );
		}
		/* hope_date */
		if( strncmp( fml_tran_rec.Flds[i].TranFldName, "acc_date", 9 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s]", fml_tran_rec.Flds[i].FldFmlId, fml_tran_rec.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, (char *)&AccDate, NULL );
		}
		if( strncmp( fml_tran_rec.Flds[i].TranFldName, "check_point", 11 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s]", fml_tran_rec.Flds[i].FldFmlId, fml_tran_rec.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, "", NULL );
		}
		if( strncmp( fml_tran_rec.Flds[i].TranFldName, "acc_type", 8 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s]", fml_tran_rec.Flds[i].FldFmlId, fml_tran_rec.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, "9", NULL );
		}
		if( strncmp( fml_tran_rec.Flds[i].TranFldName, "sex", 3 ) == 0 )
		{
			WriteLog( APP_LVL, "fld. = [%d][%s]", fml_tran_rec.Flds[i].FldFmlId, fml_tran_rec.Flds[i].TranFldName );
			Fchg32( sendbuf, fml_tran_rec.Flds[i].FldFmlId, 0, "1", NULL );
		}
	}
	
	/*打印上传包*/
	PrtFmlDetail( sendbuf );

	/*发送到PB流程*/
	memset( getstr, 0, sizeof( getstr ) );
	strcpy( getstr, getenv( "WSNADDR" ) );
	WriteLog( TEST_LVL, "oldWSNADDR = [%s]", getstr );

	port = GetLocalTuxPort();

	memset( putstr, 0, sizeof( putstr ) );
	sprintf( putstr, "WSNADDR = %s%ld", "//127.0.0.1:", port );
	putenv( putstr );
	WriteLog( TEST_LVL, "newWSNADDR = [%s]", putstr );
	rval = tpcall( AGTMAINSERVER, (char *)sendbuf, 0, (char **)&recvbuf, &RcvLen, TPNOTRAN );
	if( rval < 0 )
	{
		if( tperrno == 13 )
		{
			WriteLog( ERR_LVL, "调TUXEDO服务[%s]超时", AGTMAINSERVER );
			WriteLog( ERR_LVL, "超时，录入柜台OK!" );
			hoststat = 0;
			tpfree( (char *)sendbuf );
			tpfree( (char *)recvbuf );
			tpterm();
			/* return (-1);  Modified by MSJ - 20121226 */
			return (-13);
		}else
		{
			WriteLog( ERR_LVL, "调用TUXEDO服务[%s]失败!!tperrno=[%d]%s[%s]", AGTMAINSERVER, tperrno, tpstrerror(tperrno), getenv("WSNADDR") );
			if( tperrno == 6 || tperrno == 10 )
			{
				WriteLog( ERR_LVL, "TUXEDO服务[%s]不存在或服务错!", AGTMAINSERVER );
				hoststat = 1;
			}
			tpfree( (char *)sendbuf );
			tpfree( (char *)recvbuf );
			tpterm();
			return (-1);
		}
	}
	else
	{
		WriteLog( TEST_LVL, "调用TUXEDO服务[%s]成功!!", AGTMAINSERVER );
	}
	memset( putstr, 0, sizeof( putstr ) );
	sprintf( putstr, "WSNADDR=%s", getstr );
	putenv( putstr );
	WriteLog( TEST_LVL, "resetWSNADDR = [%s]", putstr );

	memset( getstr, 0, sizeof( getstr ) );
	strcpy( getstr, getenv( "WSNADDR" ) );
	WriteLog( TEST_LVL, "finalWSNADDR = [%s]", getstr );

	/* 打印下传包 */
	PrtFmlDetail( recvbuf );

	memset( &fml_tran_head, 0x00, sizeof( fml_tran_head ) );
	rval = GetFmlTran( FrontBuff.AreaNo, FrontBuff.ChnlNo, "0000", '1', &fml_tran_head );
	if( rval < 0 )
	{
		WriteLog( ERR_LVL, "GetFmlTran(0000) Fail ret [%d]", rval );
		tpfree( (char *)sendbuf );
		tpfree( (char *)recvbuf );
		tpterm();
		return(-1);
	}

	WriteLog(DEBUG_LVL, "fml_tran_head.FldNum=[%ld]", fml_tran_head.FldNum);

	for( i = 0;i < fml_tran_head.FldNum; i++ )
	{
		if( strncmp( fml_tran_head.Flds[i].TranFldName, "_host_stat", 11 ) == 0 )
		{
			WriteLog( TEST_LVL, "fld. = [%d][%s] ", fml_tran_head.Flds[i].FldFmlId, fml_tran_head.Flds[i].TranFldName );
			Fget32( recvbuf, fml_tran_head.Flds[i].FldFmlId ,0 ,(char *)&hoststat, NULL );
		}
		if( strncmp( fml_tran_head.Flds[i].TranFldName, "_error_code", 12 ) == 0 )
		{
			WriteLog( TEST_LVL, "fld. = [%d][%s] ", fml_tran_head.Flds[i].FldFmlId, fml_tran_head.Flds[i].TranFldName );
			Fget32( recvbuf, fml_tran_head.Flds[i].FldFmlId ,0 ,(char *)&hostmsg, NULL );
		}
	}

	tpfree( (char *)sendbuf );
	tpfree( (char *)recvbuf );

	tpterm();


	if( hoststat != 0 )
	{
		WriteLog( ERR_LVL, "录入柜台批失败! " );
		WriteLog( ERR_LVL, "hoststat[%d],HostMsg[%s] ", hoststat, hostmsg );
                PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, hostmsg, 0);
		return ( -1 );
	}else
		WriteLog( APP_LVL, "录入柜台批OK!" );

	return (0);
}

int 
gen_reg_file_snd_new( char * txtfile )
{
	EXEC SQL BEGIN DECLARE SECTION;
	long cnt = 0;
	char BatchNo1[30],InstNo1[6];
	
	EXEC SQL END DECLARE SECTION;
	char dirname[100+1];
	char bat_file[100+1];
	char gzbat_file[100+1];
	char rec_file[100+1];
	char err_msg[256+1];
	
	/*文件相关变量值*/
	char btchNb[32+1];
	char btchNm[128+1];
	char operTyp[2+1];
	int totalQnt = 0;
	double totalAmt = 0.00;
	char currencyTyp[6+1];
	char cashFlg[2+1];
	char remarkCd[16+1];
	char remark[128+1];
	char backup1[128+1];
	char backup2[128+1];
	char backup3[128+1];
	char seqNb[32+1];
	char payAcct[32+1];
	char payCustNm[128+1];
	char rcvAcct[32+1];
	char rcvCustNm[128+1];
	double amt = 0.00;
	char memo[128+1];
	char buff[30012],tmpbuff[30012],fwbuff[30012];
	char stmp[1024+1];
	char cmd[128+1];
	FILE *fp = NULL;
	int fd;
	char *p = NULL;
	char *p1 = NULL,*p2 = NULL;
	char *q = NULL;
	char tmp_str[50][128+1];
	/*文件相关变量值*/

	FILE *fw = NULL,*fwun=NULL,*frec = NULL;
	int ret = 0;
	int i = 0;
	long j = 0 ;
	int  len=0,len1=0,len2=0;
	double commission = 0.00;
	double old_amount = 0.00;
	double over_amount = 0.00;

	memset( dirname, 0, sizeof( dirname ) );
	memset( bat_file, 0, sizeof( bat_file ) );
	memset( gzbat_file, 0, sizeof( gzbat_file ) );
	memset( rec_file, 0, sizeof( rec_file ) );
	memset( err_msg, 0, sizeof( err_msg ) );
	memset( btchNb, 0, sizeof( btchNb ) );
	memset( btchNm, 0, sizeof( btchNm ) );
	memset( operTyp, 0, sizeof( operTyp ) );
	memset( currencyTyp, 0, sizeof( currencyTyp ) );
	memset( cashFlg, 0, sizeof( cashFlg ) );
	memset( remarkCd, 0, sizeof( remarkCd ) );
	memset( remark, 0, sizeof( remark ) );
	memset( backup1, 0, sizeof( backup1 ) );
	memset( backup2, 0, sizeof( backup2 ) );
	memset( backup3, 0, sizeof( backup3 ) );
	memset( seqNb, 0, sizeof( seqNb ) );
	memset( payAcct, 0, sizeof( payAcct ) );
	memset( payCustNm, 0, sizeof( payCustNm ) );
	memset( rcvAcct, 0, sizeof( rcvAcct ) );
	memset( rcvCustNm, 0, sizeof( rcvCustNm ) );
	memset( buff, 0, sizeof( buff ) );
	memset( tmpbuff, 0, sizeof( tmpbuff ) );
	memset( fwbuff, 0, sizeof( fwbuff ) );
	memset( stmp, 0, sizeof( stmp ) );
	memset( cmd, 0, sizeof( cmd ) );
	memset( BatchNo1, 0, sizeof( BatchNo1 ) );
	memset( InstNo1, 0, sizeof( InstNo1 ) );
	
	memset( memo, 0, sizeof( memo ) );
	
	/***设置批次号***/
	GetPoolDataByName( "BUSIIB", "backup2", 0, 0, BatchNo1, 0 );
	GetPoolDataByName( "ABSHEAD", "organ_no", 0, 0, InstNo1, 0 );
	strcpy(BatchNo,BatchNo1);
	strcpy(InstNo,InstNo1);
	WriteLog( APP_LVL, "batch_no[%s],inst_no[%s],hope_date[%s]\n", BatchNo1, InstNo1, AccDate );
	/* Modified by MSJ 20121226 - Start */
	EXEC SQL SELECT max(agt_num), count(*) INTO :BATCHNO, :cnt
		FROM t_pb_net_dtl
		WHERE trandate= :AccDate
		AND batchno = :BatchNo1
		AND instno = :InstNo1
		AND hopedate = :AccDate;
	/* 20121226 - End */
	if( SQLCODE && SQLCODE != 100 )
	{
		WriteLog( ERR_LVL, "查询批次管理表失败!\n" );
		return (-1);
	}
	if( cnt == 0 )
	{
		BATCHNO = 1;
	}
	else
	{
		BATCHNO ++;
	}
	WriteLog( APP_LVL, "BATCHNO[%d],cnt[%d]\n", BATCHNO, cnt );
	
	sprintf( dirname, "%s/%c%c/%s", getenv("PRINTERDIR"), InstNo[0], InstNo[1], InstNo );
	sprintf( gzbat_file, "%s/%c%c/%s/%s%s%s%d.txt.gz", getenv("PRINTERDIR"), InstNo[0], InstNo[1], InstNo, BatchNo, InstNo, AccDate, BATCHNO );
	sprintf( bat_file, "%s/%c%c/%s/%s%s%s%d.txt", getenv("PRINTERDIR"), InstNo[0], InstNo[1], InstNo, BatchNo, InstNo, AccDate, BATCHNO );
	sprintf( rec_file, "%s/%c%c/%s/%s%s%s%drec.txt", getenv("PRINTERDIR"), InstNo[0], InstNo[1], InstNo, BatchNo, InstNo, AccDate, BATCHNO );
	WriteLog( APP_LVL, "trans filename = [%s][%s] \n", bat_file,gzbat_file );
	
	/***检查目录***/
	if( access( dirname, F_OK ) != 0 )
	{
		memset( cmd, 0x00, sizeof( cmd ) );
		sprintf( cmd, "mkdir -p -m755 %s 1>/dev/null 2>&1", dirname );
		ret = system( cmd );
		if( ret != 0 )
		{
			WriteLog( ERR_LVL, "新建目录[%s]失败!\n", dirname );
			return (-1);
		}
	}
	fw = fopen( gzbat_file, "w+" );
	if( fw == NULL )
	{
		WriteLog( ERR_LVL, "打开文件[%s]失败!\n", bat_file );
		return (-1);
	}

	frec = fopen( rec_file, "w+" );
	if( fw == NULL )
	{
		WriteLog( ERR_LVL, "打开文件[%s]失败!\n", bat_file );
		return (-1);
	}
	
	/***读取文件将需要的字段写入送到核心的文件***/
	WriteLog( APP_LVL, "txtfile = [%s]\n", txtfile );
	fp = fopen( txtfile, "r" );
	if( fp == NULL )
	{
		WriteLog( ERR_LVL, "打开文件[%s]失败!\n", txtfile );
		fclose( fw );
		return (-1);
	}

	memset( buff, 0x00, sizeof( buff ) );
	len = sizeof( buff );
	if( (len1 = fread( buff, 1,  len-1 ,fp ) ) == NULL)
	{
		WriteLog( ERR_LVL, "文件为空[%d][%s][%s]!\n",ret,buff, txtfile );
		return -1;
	}
	if((p1=(char*)strstr(buff,"<fileName>")) != NULL )
	{
		if((p2=(char*)strstr(p1,"</fileName>")) != NULL )
		{
			memset(tmpbuff, 0, sizeof(tmpbuff) );
			memset(fwbuff, 0, sizeof(fwbuff) );
			memcpy(tmpbuff,p1+10,p2-p1-10);
			ret = fwrite(tmpbuff,1, p2-p1-10,frec);
			if(ret < 0 )
			{
				WriteLog( ERR_LVL, "base写入文件错");
				return -1;
			}
		}
		else
		{
			memset(tmpbuff, 0, sizeof(tmpbuff) );
			memset(fwbuff, 0, sizeof(fwbuff) );
			memcpy(tmpbuff,p1+10,strlen(p1+10)-10);

			ret = fwrite(tmpbuff,1 , strlen(p1+10)-10,frec);
			if(ret < 0 )
			{
				WriteLog( ERR_LVL, "写入文件错");
				return -1;
			}
			memcpy(buff,p1+strlen(p1+10),10);
			memset(buff+10,0,len-10);
			i=0;
			while(1)
			{
				if(i++>100)
				{
					WriteLog( ERR_LVL, "[%s][%s]报文解析失败\n", buff,p1 );
					return -1;
				}
				if( len1 == NULL)
				{
					break;
				}
				if( ( len1 = fread( buff+10, len -11,  1 ,fp )) == NULL )
				{
					WriteLog( ERR_LVL, "文件为空[%d][%s][%s]!\n",len1,buff, txtfile );
				}
				p1 = buff;
				if((p2=(char*)strstr(buff,"</fileName>")) != NULL )
				{
					memset(tmpbuff, 0, sizeof(tmpbuff) );
					memset(fwbuff, 0, sizeof(fwbuff) );
					memcpy(tmpbuff,buff,p2-p1);
					len1=strlen(tmpbuff);

					ret = fwrite(tmpbuff,1, p2-p1,frec);
					if(ret < 0 )
					{
						WriteLog( ERR_LVL, "写入文件错");
						return -1;
					}
					break;
				}
				else
				{
					memset(tmpbuff, 0, sizeof(tmpbuff) );
					memset(fwbuff, 0, sizeof(fwbuff) );
					memcpy(tmpbuff,buff,len-11);
					len1=strlen(tmpbuff);

					ret = fwrite(tmpbuff,1, len-11,frec);
					if(ret < 0 )
					{
						WriteLog( ERR_LVL, "base解码错");
						return -1;
					}
					memcpy(buff,buff+strlen(buff+10),10);
					memset(buff+10,0,len-10);
				}
			}
		}
	}
	else
	{
		WriteLog( ERR_LVL, "[%s][%s]报文解析失败\n", buff,p1 );
		return -1;
	}
		
	WriteLog( APP_LVL, "buff = [%s]\n", buff );

	fclose( fp );
	fclose( fw );
	fclose( frec );
	ret=Base64DealFile( "u", rec_file, gzbat_file );
	if( ret < 0 )
	{
		WriteLog( ERR_LVL, "base64编码失败!\n" );
	}
	fw = fopen( bat_file, "w+" );
        if( fw == NULL )
        {
                WriteLog( ERR_LVL, "打开文件[%s]失败!\n", bat_file );
                return (-1);
        }
	WriteLog( ERR_LVL, "bbb[%s]!\n", headbuf );
        fputs(headbuf,fw);
        fputs("\n",fw);
	fclose(fw);

	memset(cmd,0,sizeof(cmd));
	sprintf(cmd,"gunzip -c %s>>%s ",gzbat_file,bat_file);
	WriteLog( APP_LVL, "mmmmmmmmmmmm[%s]",cmd );
	ret = system( cmd );
/*
	if( ret != 0 )
	{
		WriteLog( ERR_LVL, "解压失败!\n" );
		return -1;
	}
*/
	return 0;

}
/*
** Function       :  BepsBase64()
** Description    :  对字符串进行base64编码
**                :  out_buf 需要进调用本函数前进行初始化
**                   
** Input          :   - in_buf 需要进行编码的字符串
**                              
** Output         :   - out_buf 编码后的base64字符串
** Return         : 
**                   
** Create         wlb 2006.1.9
*/

int 
WyBase64(char *in_buf, char *out_buf,int slen)
{
    int len1 = 0;
	int len2 = 0;
	int tag = 0;

	void Base64(char *, char*);

    for (len1=0; len1 < slen; )
    {
        Base64(in_buf + len1, out_buf + len2);
        len1 = len1 +3;
        len2 = len2 +4;


		/**暂不做换行处理**
		BASE64算法采用国际标准算法。
		进行BASE64编码时，为避免编码结果太长不方便阅读，建议对长串或文件编码时，
		每编码输出80个字符（即60个输入字符），自动插入回车换行符（0x0d0a）。
**/
		if ( (len2 - tag ) == 76 )
		{
			*(out_buf + len2) = '\n';
			len2 = len2 + 1;
			tag = len2;
		}
    }
	return( len2);
}

/*
** Function       :  BepsUnBase64()
** Description    :  对base64字符串进行base64解码
**                :  out_buf 需要进调用本函数前进行初始化
**                   
** Input          :   - in_buf 需要进行解码的字符串
**                              
** Output         :   - out_buf 解码后的字符串
** Return         : 
**                  
** Create         wlb 2006.1.9
**/

int
WyUnBase64(char *in_buf, char *out_buf,int len)
{
	int i, j;
    int len1 = 0;
	int len2 = 0;
	int slen = 0;

	void unBase64(char *, char*);

	/**先去除in_buf中的非法字符**/
	i = 0;
	j = 0;
 WriteLog( ERR_LVL, "1ccccccccccccc!\n");

	for (i = 0; i <len; i++)
	{
		if ((( in_buf[i] >=65 ) && (in_buf[i] <= 90) ) ||
			(( in_buf[i] >=97 ) && (in_buf[i] <= 122) ) ||
			(( in_buf[i] >=47 ) && (in_buf[i] <= 57) ) ||
			( in_buf[i] == 43 ) ||
			( in_buf[i] == 61 ) )
		{ 
			in_buf[j] = in_buf[i];
			j++;
		}
	}
	in_buf[j] = '\0';

	slen = len;
    for (len1=0; len1 < slen; )
    {
	if((len1%76)==0)
	{
		WriteLog( ERR_LVL, "2ccccccccccccc[%s]!\n" ,in_buf + len1);
	}
        unBase64(in_buf + len1, out_buf + len2);
        len1 = len1 +4;
        len2 = len2 +3;
	if(*(in_buf + len1)=='\n')
	{
		len1 = len1 +1;
		WriteLog( ERR_LVL, "3ccccccccccccc[%s]!\n" ,in_buf + len1);
	}
    }
    return( len2);
}

/*Base64编码*/

void 
Base64(char *chasc,char *chuue)
/*  
  chasc：未编码的二进制代码
  chuue：编码过的Base64代码
*/
{
	int i,k=2;
	unsigned char t=0; 

	for(i=0;i<3;i++)
	{
		*(chuue+i)=*(chasc+i)>>k;
		*(chuue+i)|=t;
		t=*(chasc+i)<<(8-k);
		t>>=2;
		k+=2;
	}
	*(chuue+3)=*(chasc+2)&63;

	for(i=0;i<4;i++)
	{
		if (*(chuue+i) == 0)
			*(chuue+i) = 61;
		else if((*(chuue+i)>=0)&&(*(chuue+i)<=25)) 
			*(chuue+i)+=65;
		else if((*(chuue+i)>=26)&&(*(chuue+i)<=51)) 
			*(chuue+i)+=71;
		else if((*(chuue+i)>=52)&&(*(chuue+i)<=61)) 
			*(chuue+i)-=4;
		else if(*(chuue+i)==62) 
			*(chuue+i)=43;
		else if(*(chuue+i)==63) 
			*(chuue+i)=47;
	}
}

/*Base64解码*/
void
unBase64( char *chuue, char *chasc)
/*  
chuue：未解码的Base64代码
chasc：解码过的二进制代码
*/
{
	int i,k=2;
	unsigned char t=0;
	for(i=0;i<4;i++)
	{
		if((*(chuue+i)>=65)&&(*(chuue+i)<=90)) 
			*(chuue+i)-=65;
		else if((*(chuue+i)>=97)&&(*(chuue+i)<=122)) 
			*(chuue+i)-=71;
		else if((*(chuue+i)>=48)&&(*(chuue+i)<=57)) 
			*(chuue+i)+=4;
		else if(*(chuue+i)==43) 
			*(chuue+i)=62;
		else if(*(chuue+i)==47) 
			*(chuue+i)=63;
		else if(*(chuue+i)==61) 
			*(chuue+i)=0;
	}

	for(i=0;i<3;i++)
	{
		*(chasc+i)=*(chuue+i)<<k;
		k+=2;
		t=*(chuue+i+1)>>8-k;
		*(chasc+i)|=t;
	}
}
long zbasefile(char *infile, char *outfile)
{
	char cmd[248],buff[2049],outbuff[2049];
	char tmpfile[248];
	long ret=0,len=0,i;
	long j;
	FILE *fptmp,*fp;

	memset(cmd,0,sizeof(cmd));
	memset(buff,0,sizeof(buff));
	memset(outbuff,0,sizeof(outbuff));
	memset(tmpfile,0,sizeof(tmpfile));

	strcpy(tmpfile,infile);
	strcat(tmpfile,".gz");

	sprintf(cmd,"gzip -nc  %s >%s",infile,tmpfile);
	WriteLog( ERR_LVL, "cmd[%s]\n", cmd );

	ret = system( cmd );
	WriteLog( ERR_LVL, "qqqqqqqq[%d]!",ret );
/*
	if( ret )
	{
		WriteLog( ERR_LVL, "xml文件转换出错!" );
		PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, "文件转换出错!", 0 );
		return ( -1 );
	}
*/
	ret=Base64DealFile( "e", tmpfile, outfile );
	if(ret <0 )
	{
		WriteLog( ERR_LVL, "base文件转换出错!" );
                PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, "文件转换出错!", 0 );
                return ( -1 );
	}
	return 0;
}
