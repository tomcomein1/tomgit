/*  File     : net_cert.c
 *  Action   : 凭证的文本生成
 *  用格式文件对凭证的格式进行定义，输入数据后生成凭证的文本
 *  Interface:
 *      载入凭证格式定义文件
 *      CERT * CertOpen (char *);
 *      凭证数据生成
 *      long CertGen(CERT *, FILE *, char *)
 *      凭证数据刷新入文件
 *      long CertFresh(CERT *, FILE *);
 *      关闭凭证文件
 *      long CertClose(CERT *);
 *  Author   : 陆向东 Frank Luther
 *  date     : 1998.9.26
 */
$include "mud.h";
#include <stdio.h>
#include <curses.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <unistd.h>
#include <ctype.h>
#include <string.h>
#include <strings.h>
#include <malloc.h>
#include <time.h>
#include <sys/timeb.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <errno.h>
#include <libgen.h>
#include <math.h>
#include <fcntl.h>
#include "userlog.h"
#include "fml32.h"
#include "atmi.h"
#include "pberrlog.h"
#include "CnapComm.h"

/**mod by wlb 2003.09.05****
#define MAXWIDTH   512
***/
#define MAXWIDTH   2048
#define MAXELE     250    /*由150增加到250 mod by YMC 20080111*/
#define MAXLINELEN MAXWIDTH

#define err_ret()  if (ret < 0) { free(cert); cert=NULL; fclose(fp); return (NULL);}

void *memcpy(void *, const void *, size_t );
void *malloc(size_t );
long PayGet_prt( long );
unsigned char * fmt_trans( );

/*全局变量申明*/
$ struct printer
{
    long    prt_no;
    char    reset[41];
    char    rapid[41];
    char    betf[41];
    char    n_row_spc[41];
    char    pk_row_spc[41];
    char    tbl_spc[41];
    char    change_pg[41];
    char    db_ht[41];
    char    n_ht[41];
	long    len[10];                         /*** add by rtao, for OKI mode ***/
} ;

$struct printer prt;

char  tmp[MAXWIDTH];
char  topic[MAXWIDTH];
char  cont[MAXWIDTH];
int   call_count; /* 调用记数 */
/*全局变量结束申明结束*/


long get_size();
long get_mode();
long get_pic();
long ele_init();
void get_prt_ctrl();
void page_up();
void del_cr();

long Cert_Print();
CERT * CertOpen();
long CertFresh();
long CertGen();
long CertClose();



/*   
 *   Fuction  : Cert_Print();
 *   Action   : 打印凭证文件
 *   Input    : 凭证格式文件名(全路径)，数据
 *   Output   : 凭证文件
 *   Return   :     NULL --失败
 *              NOT NULL --成功
 */
long
Cert_Print(certfile, datafile, outfile, prtno)
    char * certfile;
    char * datafile;
    char * outfile;
    long    prtno;
{
	char cmd[200];
    CERT *cert;
    FILE *datafp;
    FILE *outfp;
    char  data[MAXLINELEN+1];

    cert = CertOpen(certfile, prtno);
    if (cert == NULL) 
    {
        WriteLog(ERR_LVL, "Call CertOpen Error.");
        return ( -1 );
    }
    datafp = fopen (datafile, "r");
    if (datafp == NULL) 
    {
        WriteLog(ERR_LVL, "Can't Open Data File");
        CertClose(cert);
        return ( -1 );
    }
    if ( fgets(data, MAXLINELEN+1, datafp)!= NULL )
	{
    	outfp = fopen (outfile, "w");
    	if (outfp == NULL) 
    	{
        	WriteLog(ERR_LVL, "Can't Open Output File");
        	CertClose(cert);
    		fclose (datafp);
        	return ( -1 );
    	}
/**** 使用新的活期利息单
		// added by lan 1999/07/30 
		   to meet with int_cert print 
		   a special prtno for 套打 
        if ( prtno == 9 )
		{
            fprintf (outfp, "\n");
            fprintf (outfp, "\n");
            fprintf (outfp, "\n");

		// added by zhong 2000/06/02 适应文件合并的变化
            fprintf (outfp, "\n");
		}
**********/
        

		/*xiao zhong modify***/
        CertGen(cert, outfp, data, prtno);
		/***add end****/

    	while( !feof(datafp) )
    	{
        	memset(data, 0, sizeof data);
			if ( fgets(data, MAXLINELEN+1, datafp)!= NULL )
        	    CertGen(cert, outfp, data, prtno);
			if( ferror(datafp) )
			{ 
	    		WriteLog(ERR_LVL, strerror(errno));
    			CertClose(cert);
    			fclose (outfp);
    			fclose (datafp);
	    		return ( -1 );
        	}
    	} 
    	CertFresh(cert, outfp, prtno); 
        /***wlb 2006/12/5 add 换页**/
		fputs( "\014", outfp );
    	fclose (outfp);
	}
    CertClose(cert);
    fclose (datafp);
    return ( 0 );
}

/*   Fuction  : CertOpen();
 *   Action   : 打开凭证文件
 *   Input    : char *filename 文件名
 *   Output   : CERT *, 打开的CERT指针
 *   Return   :     NULL --失败
 *              NOT NULL --成功
 */
CERT *
CertOpen(filename, prtno)
    char *filename;
	long   prtno;
{
    long   i,j;
    CERT  *cert;
    FILE  *fp;
    long   ret;

    /*初始化*/
    cert = (CERT *)malloc( sizeof (CERT));             
    if (cert == NULL) 
	{
		return (NULL);
    }
	memset (cert, 0, sizeof (CERT));
    
    cert->num_line = 1;
    cert->num_line_curr = 0;

    cert->num_page = 1;
    cert->num_page_curr = 0;
 
    cert->num_space = 1;
 
    cert->mode = 0; 
   
    /*打开文件*/
    fp = fopen (filename, "r");
    if (fp == NULL) 
    {
        free (cert);
        return (NULL);
    }
    
    if( PayGet_prt(prtno) != 0 )
	    WriteLog(ERR_LVL, "Call PayGet_prt Error");
    ret = get_mode(cert , fp);
    err_ret();
    ret = get_size(cert , fp);
    err_ret();
    ret = get_pic(cert , fp);
    err_ret();
    ret = ele_init (cert);
    err_ret();
     
    fclose(fp);
    return (cert);
}

long 
get_size(cert, fp)
    CERT *cert;
    FILE *fp;
{
    long i;
    /* 读取文件中的定制数据*/ 
    while (1) 
    {
         fgets(tmp, MAXWIDTH, fp);     
         if (feof(fp) != 0) /* 文件尾 */
              return (-1);
         del_cr(tmp);
         if ((tmp[0] == '#')||(tmp[0] == '\0')) continue;  /* 注释行*/
         sscanf (tmp, "%s%s", topic, cont);  
         if (0 != strcmp(topic, "SIZE"))
         {
               return -1;  /* 不是size 字段出错*/
         }
         else  
         {
             for (i = 0; i < MAXWIDTH; i ++) 
             {
                 if (cont[i] == 'x') /* 将一个字符串分成两个*/ 
                 {
                      cont[i] = 0;
                      break;
                  }
             }
             if (i == MAXWIDTH) /*  找不到x */ 
                 return (-1);
             cert->width = atoi(cont);
             cert->length = atoi(cont+i+1);
             if ((cert->width == 0)||(cert->length == 0))
                 return (-1);
             return (0);
         }        
    }
}
long 
get_mode(cert, fp)
    CERT *cert;
    FILE *fp;
{ 
    long  i;
    long  j;
    char *str;
    long  val;
   
    memset(topic, 0, sizeof(topic));
    memset(cont, 0, sizeof(cont));
    while (1) 
    {
         memset (tmp, 0, MAXWIDTH);
         fgets(tmp, MAXWIDTH, fp);     
         if (feof(fp) != 0) /* 文件尾 */
              return (-1);
         del_cr(tmp);
         if ((tmp[0] == '#')||(tmp[0] == '\0')) continue;  /* 注释行*/
         sscanf (tmp, "%s%s", topic, cont);  
         if (0 != strcmp(topic, "MODE")) 
              return -1;
         else 
         {
             str = cont;
             while(*str) 
             {
                 while(*str && !isdigit(*str)) ++str;
                 if(!(*str)) return 0;
                 val=0;
                 while(isdigit(*str)) 
                 {
                     val=val*10+(*str-'0'); 
                     ++str;
                 }
                 switch(*str) {
                 case 'L':
					  if (val == 0)
						   val = 1;
                      cert->num_line = val;
                      break;
                 case 'P':
					  if (val == 0)
						   val = 1;
                      cert->num_page = val;
                      break;
                 case 'F':
                      cert->mode = val;
                      break;
                 case 'S':
                      cert->num_space = val;
                      break;
                 default :
                      break;
                 }
             }
             return (0);      
         }
     }
}        

long 
get_pic(cert, fp)
    CERT *cert;
    FILE *fp;
{ 
    long i;
    long j;
    long k;
    long l;
    long len;
    char tmp_str[20];
   
    memset(topic, 0, sizeof(topic));
    memset(cont, 0, sizeof(cont));

    cert->pic = (PIC_LINE *)malloc(cert->length*sizeof(PIC_LINE ));
    if (cert->pic == NULL) 
        return (-1);
    memset (cert->pic, 0, cert->length*sizeof(PIC_LINE));
    for (i = 0; i<cert->length; i++) 
    {
        ((cert->pic)[i]).line = malloc(MAXWIDTH);
        if ((((cert->pic)[i]).line) == NULL) 
             return (-1);
        memset (((cert->pic)[i]).line, 0, MAXWIDTH);
        memset (((cert->pic)[i]).line, 1, MAXWIDTH-1);
    }
    while (1) 
    {
         memset (tmp, 0, MAXWIDTH);
         fgets(tmp, MAXWIDTH, fp);     
         if (feof(fp) != 0) /* 文件尾 */
              return (-1);
         del_cr(tmp);
         if ((tmp[0] == '#')||(tmp[0] == '\0')) continue;  /* 注释行*/
         sscanf (tmp, "%s", topic);  
         if (0 != strcmp(topic, "PIC_DESC_BEGIN")) 
              return -1;
         else 
         {
              for (i = 0; i < cert->length; i++) 
              {
                  memset (tmp, 0, MAXWIDTH);
                  fgets(tmp, MAXWIDTH, fp);
                  if (feof(fp) != 0) /* 文件尾*/
                      return -1;
                  del_cr(tmp);
                  sscanf(tmp, "%s", topic);
                  if (0 == strcmp(topic, "PIC_DESC_END")) 
                  {
                      for (j = i ; j<cert->length; j++)
                      {
                           cert->pic[j].act_len = cert->width;
                           memset(cert->pic[j].line, ' ', cert->width); 
                      }
                      return 0;
                  }
                  for (j=0,k=0,l=0; j<MAXWIDTH; j++, k++)
                  {
                       if (tmp[j] == '\0') break; 
                       if (tmp[j] == '~') 
                       {
							memset( tmp_str, 0, sizeof( tmp_str ) );
                          get_prt_ctrl(tmp[j+1], tmp_str, &len);
                          memcpy (((cert->pic[i].line)+k), tmp_str, len); 
                          j += 1;
                          k += len - 1;
                       }
                       else { 
                          memcpy ((((cert->pic)[i]).line)+k , tmp+j, 1);
                          l++;
                          if (l>cert->width) 
                              break;
                      }
                  }
                  if (l<cert->width) 
                  { 
                      memset ((cert->pic[i].line)+k, ' ', cert->width-l);
                      cert->pic[i].act_len = k+cert->width-l;
                  }
                  else 
                      cert->pic[i].act_len = k;
              } 
              while (1) 
              {
                  memset (tmp, 0, MAXWIDTH);
                  fgets(tmp, MAXWIDTH, fp);
                  if (feof(fp) != 0) /* 文件尾*/
                      return -1;
                  del_cr(tmp);
                  sscanf(tmp, "%s", topic);
                  if (0 == strcmp(topic, "PIC_DESC_END")) 
					   return (0);
              }
         }
     }
}        


long 
ele_init(cert)
    CERT *cert;
{
    long i;
    long j;
    long k;
    long l;
    
    k = 0; 
    
    cert->ele = (ELE_CERT *)malloc(MAXELE*sizeof(ELE_CERT));
    memset (cert->ele, 0, MAXELE*sizeof(ELE_CERT));
    if (cert->ele == NULL) return (-1);
    for (i = 0 ; i < cert->length; i++)
    {
        for (j = 0 ; j < cert->pic[i].act_len; j++)
        {
            if (k >= MAXELE) return (-1); 
            if (cert->pic[i].line[j]=='@')
            {
                cert->ele[k].pos_x = j;
                cert->ele[k].pos_y = i;
                cert->ele[k].mode = 0; /* left adjust */
                for (l = 1;; l++) 
                     if (cert->pic[i].line[j+l] != '@') break;
                cert->ele[k].len = l;
                cert->ele[k].data = malloc (cert->num_line * cert->ele[k].len);
                if ((cert->ele[k].data) == NULL) 
                     return (-1);
                j += l;
                k++;
                continue;
              
            }
            if (cert->pic[i].line[j]=='&')
            {
                cert->ele[k].pos_x = j;
                cert->ele[k].pos_y = i;
                cert->ele[k].mode = 1; /* right adjust */
                for (l = 1;; l++) 
                     if (cert->pic[i].line[j+l] != '&') break;
                cert->ele[k].len = l;
                cert->ele[k].data = malloc (cert->num_line * cert->ele[k].len);
                if ((cert->ele[k].data) == NULL) 
                     return (-1);
                j += l;
                k++;
                continue;
          }
        }
    }
    cert->num_ele = k; 
    return ( 0 );
}
 
long CertGen(cert, fp, data, prtno)
    CERT *cert;
    FILE *fp;
    char *data;
    long  prtno;
{
    long  i;
    long  j;
    long  k;
    long  pre_pstn;
    long  ret_val;
    short len;
    char *str; 


    str = data;
    if (cert->num_line_curr == cert->num_line)  
    {
          ret_val = CertFresh (cert, fp, prtno);
          if (ret_val < 0) return (ret_val);
          cert->num_line_curr = 0;
    }                    
    len = strlen (data);
    /* Commented by MSJ for chinese character - 20150424 */
    /** for (i = 0, k = 0, pre_pstn = 0; i < len; i++) **/ 
    for (i = 0, k = 0, pre_pstn = 0; i < len; ) 
    {
         if ((data[i] == '|')||(i==len-1)) {
              memset (cont, 0, MAXWIDTH);
              if(i==len-1 && data[i] != '|' )
			      memcpy (cont, data+pre_pstn, i-pre_pstn+1);
			  else
				  memcpy (cont, data+pre_pstn, i-pre_pstn);
              cont[cert->ele[k].len] = 0;
              switch (cert->ele[k].mode) 
              {
              case 0:  /* left adjust */
                   sprintf (tmp, "%-*s", cert->ele[k].len, cont);
                   break;
              case 1:  /* right adjust */ 
                   sprintf (tmp, "%*s", cert->ele[k].len, cont);
                   break;
              }
              memcpy ((cert->ele[k].data)+cert->num_line_curr*cert->ele[k].len, tmp, cert->ele[k].len);
              pre_pstn = i + 1;
              k++;
              if (k > cert->num_ele) break;
         }
         /* Added by MSJ for chinese character 20150424 - Start */
         if( data[i] > 0x80 )
         {
             /**WriteLog( APP_LVL, "遇汉字，跳两个字节" );**/
             i = i+2;
         }
         else
             i++;
         /* Added by MSJ for chinese character 20150424 - End */
    }
	for (i=k; i<cert->num_ele; i++)
        memset ((cert->ele[i].data)+cert->num_line_curr*cert->ele[i].len, ' ', cert->ele[i].len);
    (cert->num_line_curr)++;
    return (0);
}
        
long
CertFresh(cert, fp, prtno)
    CERT *cert;
    FILE *fp;
    long  prtno;
{
    long  i;
    long  j;
    long  k;
	long  p,q;   /***  add by rtao, for OKI MODE ***/
    long  size;
    long  len;
    long  pos_x;
    long  pos_y;
    char **buff;
    
    
    if (cert->num_line_curr == 0 ) 
         return (0); 
    buff = malloc(cert->length*sizeof(char *));
    if (buff == NULL)
        return (-1);
    
    /**************************************
	    proc at 1999/07/31 to 
	    deal with change page: lan
    **************************************/
    if (cert->num_page_curr >= cert->num_page) 
    {
        page_up (fp);
        cert->num_page_curr = 0;
    }
	else if ( cert->num_page_curr != 0 )
	{
        for (i = 0; i < cert->num_space; i++)
            fprintf (fp, "\n");
    }
    /****  added  end  ****/
    
    for (i = 0; i<cert->length; i++)
    {
        buff[i] = malloc ((cert->pic[i].act_len)*(cert->num_line));
        if (buff[i] == NULL)
        {
            for (j = 0; j < i; j++) 
                free(buff[j]); 
            free (buff); 
            return (-1);
        }
    }
    
    if (cert->mode == 0)  /* with frame */
    {
        for (i = 0; i < cert->length; i++)
        {
            len = cert->pic[i].act_len;
            for (j = 0 ;j <cert->num_line_curr; j++)
                 memcpy(buff[i]+j*len, cert->pic[i].line, len); 
        }
    }
    else if (cert->mode == 1)  /* with no frame */
    {
        for (i = 0; i < cert->length; i++)
        {
            len = cert->pic[i].act_len;
            memset(buff[i], ' ', len*cert->num_line_curr); 
        }
    }
    for (i = 0; i < cert->num_ele; i++)
    {
        pos_y = cert->ele[i].pos_y;
        len = cert->pic[pos_y].act_len;
        for (j = 0 ;j <cert->num_line_curr; j++)
        {
            pos_x = cert->ele[i].pos_x+j*len;
            memcpy(buff[pos_y]+pos_x, cert->ele[i].data+j*cert->ele[i].len,cert->ele[i].len); 
        }

    }
    if( PayGet_prt(prtno) != 0 )
    {
	    WriteLog(ERR_LVL, "Call PayGet_prt Error");
	    return ( -1 );
    }
	/*********  modified by rtao, for OKI mode 
    fprintf(fp, prt.reset);
    fprintf(fp, prt.n_row_spc);
    fprintf(fp, prt.n_ht);
	 ********/

	 for (i=0; i < prt.len[1]; i++)
	   fputc(prt.reset[i], fp);

	 for (i=0; i < prt.len[4]; i++)
	   fputc(prt.n_row_spc[i], fp);

	 for (i=0; i < prt.len[9]; i++)
	   fputc(prt.n_ht[i], fp);

     /*******  modified end  ********/

    for (i = 0; i < cert->length; i++)
    {
        len =  (cert->pic[i].act_len)*(cert->num_line_curr);
        for (j = 0; j < len; j++)
        {
            if (buff[i][len-j-1] == ' ') 
				continue;

		/******** modified by rtao, for OKI MODE
	    fprintf(fp, prt.betf);
		 *******/

		 	for ( p = 0; p < prt.len[3]; p++ )
				fputc(prt.betf[p], fp);

         /*****  modified end  *******/

			for ( q = 0; q < len-j; q++ )
			{
				if( buff[i][q] == '`' )
				{
					for ( p = 0; p < prt.len[8]; p++ )
						fputc(prt.db_ht[p], fp);
				}
				else if( buff[i][q] == '~' )
				{
					for ( p = 0; p < prt.len[9]; p++ )
						fputc(prt.n_ht[p], fp);
				}
				else
					fputc( buff[i][q], fp );
			}
/*   for OKI PRINTER yangtun change 2001/09/23
            fwrite (buff[i], len-j, 1, fp);
*/
            break;
        }
        fprintf (fp, "\n");
    }
	
    cert->num_line_curr = 0;
    cert->num_page_curr ++;
    /**************************************
	    proc at 1999/07/31 to 
	    deal with change page: lan
    if (cert->num_page_curr >= cert->num_page) 
    {
        page_up (fp);
        cert->num_page_curr = 0;
        return (0);
    }
    
    for (i = 0; i < cert->num_space; i++)
        fprintf (fp, "\n");
    *************************************/


	/****zsl add free buff***/
    for (i = 0; i<cert->length; i++)
	{
		free(buff[i]);
	}
	free(buff);
	/***add end****/

    return (0);
}

long
CertClose(cert)
    CERT *cert;
{
    long i,j;

    for (i = 0; i <cert->length; i++)
        free(cert->pic[i].line); 
    for (i = 0; i <MAXELE; i++)
        free(cert->ele[i].data);
    free(cert->pic);
    free(cert->ele);
    free(cert);
    return 0;
}
void
get_prt_ctrl(c, str, len)
    long c;
    char *str;
    long  *len;
{

    memset(str, 0, sizeof str);
    switch( c )
	{
	case 'R':
		/***
        strcpy(str, prt.rapid);
		 ***/
		memcpy(str, prt.rapid, prt.len[2]);
		*len = prt.len[2];
		break;
	case 'B':
		/***
        strcpy(str, prt.betf);
         ***/
		 memcpy(str, prt.betf, prt.len[3]);
		*len = prt.len[3];
		break;
	case 'N':
		/***
        strcpy(str, prt.n_row_spc);
		 ***/
		 memcpy(str, prt.n_row_spc, prt.len[4]);
		*len = prt.len[4];
		break;
	case 'P':
		/***
        strcpy(str, prt.pk_row_spc);
		 ***/
         memcpy(str, prt.pk_row_spc, prt.len[5]);
		*len = prt.len[5];
		break;
	case 'T':
		/***
        strcpy(str, prt.tbl_spc);
		 ***/
		 memcpy(str, prt.tbl_spc, prt.len[6]);
		*len = prt.len[6];
		break;
	case 'C':
		/***
        strcpy(str, prt.change_pg);
		 ***/
		 memcpy(str, prt.change_pg, prt.len[7]);
		*len = prt.len[7];
		break;
	case 'D':
		/***
        strcpy(str, prt.db_ht);
		 ***/
		 memcpy(str, prt.db_ht, prt.len[8]);
		*len = prt.len[8];
		break;
	case 'H':
		/***
        strcpy(str, prt.n_ht);
		 ***/
		 memcpy(str, prt.n_ht, prt.len[9]);
		*len = prt.len[9];
		break;
    default:
		strcpy(str, "");
		*len = 0;               /*** add by rtao, for OKI MODE ***/
		break;
    }
    
	/*** modified by rtao, for OKI MODE ***
	*len = strlen(str);
	 ***/


	/**
	printf("%s, len = %d\n", str, *len);
	**/
}

void 
page_up(fp)
    FILE *fp;
{
	long i;
	/******* modified by rtao,  for OKI mode 
    fprintf(fp, prt.change_pg);
	 *******/

     for ( i=0; i < prt.len[7]; i++)
	   fputc(prt.change_pg[i], fp);

    /****  modified end ******/

	/****  1999/07/30
	 change here using database data
	 in order to match int_cert's print 
	 and no change any other source code
    
	fprintf (fp, "\014");
	****/
}
void 
del_cr(str)
    char *str;
{
    long i;
    for (i = 0; i < MAXWIDTH; i++) 
    {
         if ((str[i] == '\n')||(str[i] == '\r')) 
              str[i] = 0;
    }
}


long
PayGet_prt(prt_no)
    $ long prt_no;
{
    $ SELECT prt_no, reset, rapid, betf, n_row_spc, pk_row_spc, tbl_spc, 
             change_pg, db_ht, n_ht
        INTO $prt.prt_no, $prt.reset, $prt.rapid, $prt.betf, $prt.n_row_spc, $prt.pk_row_spc, $prt.tbl_spc, $prt.change_pg, $prt.db_ht, $prt.n_ht  
        FROM t_pb_prt_para 
        WHERE prt_no = $prt_no; 

    if (sqlca.sqlcode)
    {
        WriteLog(ERR_LVL, "SQLCODE=[%d]", sqlca.sqlcode);
        return ( -1 );
    }
	rtrim(prt.reset);
	rtrim(prt.betf);
	rtrim(prt.n_row_spc);
	rtrim(prt.pk_row_spc);
	rtrim(prt.tbl_spc);
	rtrim(prt.change_pg);
	rtrim(prt.db_ht);
	rtrim(prt.n_ht);
    fmt_trans(prt.reset,  &(prt.len[1]));
    fmt_trans(prt.rapid,  &(prt.len[2]));
    fmt_trans(prt.betf,   &(prt.len[3]));
    fmt_trans(prt.n_row_spc,  &(prt.len[4]));
    fmt_trans(prt.pk_row_spc, &(prt.len[5]));
    fmt_trans(prt.tbl_spc,    &(prt.len[6]));    
    fmt_trans(prt.change_pg,  &(prt.len[7]));
    fmt_trans(prt.db_ht,      &(prt.len[8]));     
    fmt_trans(prt.n_ht,       &(prt.len[9]));

    return ( 0 );
}
unsigned char *
fmt_trans(s, len)
    unsigned char * s;
	long *len;
{
    unsigned char *ps,*pt,*t;
	unsigned char str[100];
    long ch,base,ch0;

	long	i;
	long	j = 0;

	memset( str, 0, sizeof( str));
    ps = s;
	/*
    pt = (unsigned char *)malloc(strlen((char *)ps)+1);
	*/
	pt = str;

    t = pt;
    if (!pt) 
    return s;
    while (*ps) 
    {
        if (*ps == '\\') 
        {
            ps ++;
            switch(*ps) 
            {
            case 'f':
                ch = '\f';
                break;
            case 'r':
                ch = '\r';
                break;
            case 'n':
                ch = '\n';
                break;
            case '\\':
                ch = '\\';
                break;
            case 'x':
                ps ++;
                base = 16;
                ch = (*ps >= 'a' && *ps <= 'f') ? (*ps-'a')+10 :
                  ((*ps >= 'A' && *ps <= 'F') ? (*ps-'A')+10 :
                  ((*ps >= '0' && *ps <= '9') ? (*ps-'0') : (-1)));
                if (ch < 0) 
                    continue;
                ps ++;
                ch0 = (*ps >= 'a' && *ps <= 'f') ? (*ps-'a')+10 :
                  ((*ps >= 'A' && *ps <= 'F') ? (*ps-'A')+10 :
                  ((*ps >= '0' && *ps <= '9') ? (*ps-'0') : (-1)));
                if (ch0 >= 0) 
                {
                    ch = ch * base + ch0;
                    ps ++;
                }
                break;
            case 'o':
                base = 8;
                ps ++;
                ch = (*ps >= '0' && *ps <= '7') ? (*ps-'0') : (-1);
                if (ch < 0) 
                    continue;
                ps ++;
                ch0 = (*ps >= '0' && *ps <= '7') ? (*ps-'0') : (-1);
                if (ch0 >= 0) 
                {
                    ch = ch * base + ch0;
                    if (ch > 255) 
                    {
                        ch = (ch - ch0) / base;
                        break;
                    }
                    ps ++;
                    ch0 = (*ps >= '0' && *ps <= '7') ? (*ps-'0') : (-1);
                    if (ch0 >= 0) 
                    {
                        if (ch > 255) 
                        {
                            ch = (ch - ch0) / base;
                            break;
                        }
                        ch = ch * base + ch0;
                        ps ++;
                    }
                }
                break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
                base = 8;
                ch = (*ps >= '0' && *ps <= '7') ? (*ps-'0') : (-1);
                if (ch < 0) 
                    continue;
                ps ++;
                ch0 = (*ps >= '0' && *ps <= '7') ? (*ps-'0') : (-1);
                if (ch0 >= 0) 
                {
                    ch = ch * base + ch0;
                    if (ch > 255) 
                    {
                        ch = (ch - ch0) / base;
                        break;
                    }
                    ps ++;
                    ch0 = (*ps >= '0' && *ps <= '7') ? (*ps-'0') : (-1);
                    if (ch0 >= 0) 
                    {
                        ch = ch * base + ch0;
                        if (ch > 255) 
                        {
                            ch = (ch - ch0) / base;
                            break;
                        }
                        ps ++;
                    }
                }
                break;
            default:
                ch = *ps;
                break;    
            }
            *pt++ = ch;
			
			/*  add  by rtao, for OKI 方式 */
			j++;

        } 
        else 
			{
              *pt++ = *ps++;
			  /*  add  by rtao, for OKI 方式 */
			  j++;
            }
    }
    *pt = '\0';

     memcpy((char *)s, (char *)t,j);  
	 /* modified by rtao, for OKI Mode */
	 s[j] = '\0';

	 *len = j;

	/*
    free(t);
	*/
    return s;
}
