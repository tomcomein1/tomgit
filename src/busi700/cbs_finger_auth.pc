#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <time.h>
#include "pbconstval.h" 
#include "pbstructdef.h" 
#ifdef ORACLE_DATABASE
EXEC SQL include "pbranchdb.h";
#else
#include "pbranchdb.h"
#endif
#include "pberrlog.h"
#include "pbglbvardef.h"
#include "pbbasefunc.h"
#include "pbvarmacro.h"


/*
 * FileNmae         :     cbs_finger_auth.pc
 * Decrsiption      :     网银--柜员指纹认证 
 * -----------------------------------------------------------
 * PROGRAMMER     | DATE   | 
 * -----------------------------------------------------------
 *  LIUQ          | 20110926|
 * -----------------------------------------------------------
 */

/* 到指纹数据服务器验证指纹 */
int CbsFingerAuth();

int
CbsFingerAuth() 
{
    char tellerId[6];
    char paramType[3];
    char tmpdata[1025];
    char fingerdata[514];
    char para[30];
    char err_msg[100];
    char retcode[5];
    char pattern[20];
    char fgbuf[1025];
    long ret ;
    long errcode ;
    long hoststat ;

	char tmpbuf[PACKDATA_LEN+1];
    int PkgLen = 0;
    int posret = 0;
    int firstpos = 0;
    int lastpos = 0;

    ret      = 0;
	hoststat = 0;
    errcode  = 99999; /* 预先设置返回码为-其他错*/

    memset( tellerId,      0x00, sizeof(tellerId) );
    memset( paramType,     0x00, sizeof(paramType) );
    memset( fingerdata,    0x00, sizeof(fingerdata) );
    memset( tmpdata,       0x00, sizeof(tmpdata) );
    memset( err_msg,       0x00, sizeof(err_msg) );
    memset( retcode,       0x00, sizeof(retcode) );
    memset( pattern,       0x00, sizeof(pattern) );
    memset( fgbuf  ,       0x00, sizeof(fgbuf) );

    memset( tmpbuf, 0x00, sizeof(tmpbuf) );
    memcpy( tmpbuf, PkgBuff.DataBuff+24, PkgBuff.DataLen - 24 );
    memset( PkgBuff.DataBuff, 0x00, sizeof(PkgBuff.DataBuff) );

    PkgBuff.DataLen -= 24;
    memcpy( PkgBuff.DataBuff, tmpbuf, PkgBuff.DataLen );
    WriteLog( ERR_LVL, "DataBuff[%s][%d]", PkgBuff.DataBuff, PkgBuff.DataLen );
	
	if (PkgBuff.DataLen == 0 )
	{
        sprintf( err_msg, " 接收到报文为空!");
        PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
        WriteLog(ERR_LVL, "接收到报文为空!");
        return (-1);
	}
	strcpy(pattern, "fingerprint" );
	trim(pattern);
	firstpos = Index_BF (  PkgBuff.DataBuff, pattern, PkgBuff.DataLen, 0 );
    WriteLog( ERR_LVL, "firstpos[%d]",firstpos);
	if ( firstpos = -1 )
	{
        sprintf( err_msg, " 字符串处理出错!");
        PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
        WriteLog(ERR_LVL, "字符串处理出错!" );
        return (-1);
	}
	lastpos  = Index_BF (  PkgBuff.DataBuff, pattern, PkgBuff.DataLen, firstpos );
    WriteLog( ERR_LVL, "lastpost[%d]",lastpos);
	if ( lastpos = -1 )
	{
        sprintf( err_msg, " 字符串处理出错!");
        PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
        WriteLog(ERR_LVL, "字符串处理出错!" );
        return (-1);
	}
	memcpy(fgbuf, PkgBuff.DataBuff+firstpos+12,lastpos-firstpos-14 );
    WriteLog( ERR_LVL, "fgbuf[%s],copy len[%d]", fgbuf, lastpos-firstpos-14 );
	

    /* 返回信息 预先赋值 */
    PutPoolDataByName( "ABSHEAD", "app_err_no", 0, 0,  &errcode, 0 ); 
    PutPoolDataByName( "BUSIIB", "thsretCd", 0, 0, "399999", 0 );
    /* 取请求报文数据 */
    GetPoolDataByName( "FINGER", "tellerId",   0, 0, tellerId,   0 ); 
    GetPoolDataByName( "FINGER", "paramType",  0, 0, paramType,  0 ); 
    GetPoolDataByName( "FINGER", "fingerprint", 0, 0, fingerdata, 0 ); 

    if ( strlen( tellerId ) == 0 )
    {
        sprintf( err_msg, " 输入柜员号为空!");
        PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
        WriteLog(ERR_LVL, "输入的柜员号为空!");
        return (-1);
    }

    if ( strlen( paramType ) == 0 )
    {
        sprintf( err_msg, " 输入密码类型为空!");
        PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
        WriteLog(ERR_LVL, "输入的密码类型为空!");
        return (-1);
    }

    if ( strlen( fingerdata ) == 0 )
    {
        sprintf( err_msg, " 输入指纹数据为空!");
        PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
        WriteLog(ERR_LVL, "输入指纹数据空!");
        return (-1);
    }

    /* 若密码类型为指纹 */
    if ( strcmp( paramType, "2" ) == 0 )
    {

        /* 组包到指纹服务器 */
        PutPoolDataByName( "FIGTOCA", "trancode",   0, 0, "0100", 0 ); 
        PutPoolDataByName( "FIGTOCA", "syscode",    0, 0, "0001", 0 ); 
        PutPoolDataByName( "FIGTOCA", "tellerId",   0, 0, tellerId, 0 ); 
        PutPoolDataByName( "FIGTOCA", "fgdata",     0, 0, fingerdata, 513 ); 

       /* 取跟踪码 */
        ret = Data_GetTraceCode( "700" );

        if( ret != 0 )
        {
            sprintf( err_msg, " 取跟踪码出错!");
            PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
            WriteLog(ERR_LVL, "取跟踪码出错[%ld]", ret);
            return (-1);
        }
        /* 根据外部格式号打包 */
        memset( para, 0,  sizeof(para) );
        sprintf( para, "P|700|720010" );
        ret = Data_Pack( para );
        if( ret != 0 )
        {
            sprintf( err_msg, " 打包出错!");
            PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
            WriteLog( ERR_LVL, "Data_Pack Err");
            return (-1);
        }

        
        /* 收发数据 */ 
        memset ( para, 0, sizeof(para));
        sprintf( para, "804001|912348" );

        if ( Comm_SockCall(para) )
        {
            WriteLog(ERR_LVL, " Call Comm_SockCall Err! [%s] [%d]\n ", __FILE__, __LINE__);
            PutPoolDataByName( "ABSHEAD", "_host_stat", 0, 0, &hoststat, 0 );
            PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0,"与CA通信错", 0 );
            WriteLog( ERR_LVL, "收发数据包出错Comm_AcCall Err!返回码[%d]!", ret);
            return (-1);
        } 
        /* 根据外部交易码解包 */
        ret = Data_Unpack( "P|700|700011" );
        if( ret != 0 )
        {
            sprintf( err_msg, " 解包出错!");
            PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
            WriteLog( ERR_LVL, "Data_Unpack Err" );
            return (-1);
        }
        GetPoolDataByName( "FIGTOCA", "retcode", 0, 0, retcode, 0 );
        GetPoolDataByName( "FIGTOCA", "retmsg", 0, 0, err_msg, 0 );
        Trim(retcode);
        if ( strcmp( retcode ,"0000" ) != 0 )
        {
            Trim(retcode);
            errcode = atoi(retcode);
            PutPoolDataByName( "ABSHEAD", "app_err_no", 0, 0, &errcode, 0 ); 
            PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, "指纹验证失败!", 0 );
            WriteLog( ERR_LVL, "CA 验证失败 Err");
            return (-1);
        }
        /* 验证成功 */
        errcode = 0;
        sprintf(err_msg,"验证成功");

        PutPoolDataByName( "ABSHEAD", "app_err_no", 0, 0, &errcode, 0 ); 
        PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
        PutPoolDataByName( "BUSIIB", "thsretCd", 0, 0, "000000", 0 );
        PutPoolDataByName( "BUSIIB", "thsdesc",  0, 0, err_msg,  0 );
		return 0;

    } else /* 非指纹验证  */
    {
        errcode = 99999;
        sprintf(err_msg,"非指纹验证!");

        PutPoolDataByName( "ABSHEAD", "app_err_no", 0, 0, &errcode, 0 ); 
        PutPoolDataByName( "ABSHEAD", "_error_code", 0, 0, err_msg, 0 );
        PutPoolDataByName( "BUSIIB", "thsretCd", 0, 0, "399999", 0 );
        PutPoolDataByName( "BUSIIB", "thsdesc",  0, 0, err_msg,  0 );
		return (-1);
    }

}

int Index_BF ( char *S, char *T, int slen,int pos ) 
{ 
	/* 若串 S 中从第pos(S 的下标0≤pos<StrLength(S))个字符起存在和串 T 相同的子串， 则称匹配成功，返回第一个 这样的子串在串 S 中的下标，否则返回 -1   
	*/
	int i = pos, j = 0 ,mlen = slen; 

	/* while ( S[i+j] != '\0'&& T[j] != '\0')  */

	while ( (i+j) < mlen && T[j] != '\0')  
	if ( S[i+j] == T[j] ) 
		j ++;  /* 继续比较后一字符 */
	else 
	{ 
		i ++; 
		j = 0; /* 重新开始新的一轮匹配 */
	}
	if ( T[j] == '\0') 
		return i; /* 匹配成功   返回下标 */
	else 
		return -1; /* 串S中(第pos个字符起)不存在和串T相同的子串 */
}  
/* Index_BF */
